# CUPID

_This is russian translation._  
Original post: https://dannorth.net/cupid-for-joyful-coding  
Author: https://mas.to/@tastapod

Автор перевода: https://t.me/noncommunicado  
Подписывайтесь: https://t.me/Dev4Devs

# Введение

То, что начиналось как легкомысленное иконоборчество, подначивание деушки SOLID'а, превратилось в нечто более конкретное и осязаемое.  
Если я считаю, что принципы SOLID бесполезны в текущих реалияъ, то чем бы я их заменил?  
Может какой-либо набор принципов быть применимым ко всему программному обеспечению?  
Что мы вообще подразумеваем под принципами?

Я считаю, что существуют такие свойства (характеристики) кода, которые делают работу с ним **удовольствием**.  
Чем больше в вашем коде таких качеств, тем приятнее с ним работать.  
Но все является компромиссом, поэтому - вы всегда должны учитывать свой контекст.

Вероятно, существует множество таких свойств, пересекающихся и взаимосвязанных, и существует множество способов их описания.  
Я выбрал **пять**, которые лежат в основе большей части того, что меня волнует в коде.  
Существует _убывающая отдача_, пяти свойств достаточно, чтобы легко их запомнить и сделать удобный акроним.

> Закон убывающей отдачи (или Закон убывающей доходности) - гласит, что существует такая точка увеличения одного из факторов производительности, в данном случае количества слов в акрониме, при достижении которой, производительность начинает падать.  
> Иными словами, больше (слов в акрониме) - не значит лучше.

Я подробнее расскажу о каждом свойстве в будущих статьях, чтобы эта не получилась слишком длинной, поэтому, пожалуйста, простите меня за то, что я не описал все более подробно.

## Свойства CUPID

-   **Сочетаемость** <sup>Composable</sup> : хорошо сочетается с другими
-   **Философия Unix** <sup>Unix philosophy</sup> : хорошо решает одну задачу
-   **Предсказуемость** <sup>Predictable</sup> : делает то, что вы ожидаете
-   **Идиоматичность** <sup>Idiomatic</sup> : кажется естественным
-   **Доменность** <sup>Domain-based</sup> : домен решения моделирует домен проблемы при помощи языка и структуры

## Преамбула: давным-давно…

> У вас было, что исследуя незнакомый чужой код, вы можете его легко понять?  
> Структура, наименование, ход мыслей автора, всё выглядит очень знакомо.  
> На вашем лице появляется улыбка.  
> «Мне все понятно!» — думаете вы.

Мне повезло испытать это несколько раз за тридцатилетнюю карьеру, и каждый раз это приносило мне удовольствие.  
Первый раз это было в начале 1990-х — я хорошо это помню.  
Я изучал огромную кодовую базу на языке `C`, которая выполняла сложную обработку изображений для цифровой печати. ​​  
В `Someone Else’s Code`™ была ошибка, и я должен был ее отследить и исправить.  
Я помню это чувство, как начинающего программиста: смесь страха и боязнь выдать себя как любителя, которым я и был тогда.

Моя IDE (`vi` + `ctags`) позволила мне перейти к определениям функций из мест вызовов, и через несколько минут я зашел далеко по цепочке вызовов, будучи уверенным, что знаю, на что смотрю.  
Я быстро нашел виновника, которым была простая логическая ошибка, внес изменения, сделал сборку и протестировал.  
Все это было без автоматического тестирования, только с помощью `Makefiles`.  
TDD я узнал только, почти, через 10 лет, и в любом случае в `C` не было таких инструментов.

Я запустил преобразование на нескольких образцах изображений, и они выглядели нормально.  
Я был невероятно уверен, что:

-   Нашел и исправил ошибку.
-   В то же время, не внес никаких неприятных сюрпризов.

# Joyful Software

Бывает код, с которым приятно работать.  
Вы знаете, как найти то место, где нужно внести правки, и как их сделать.  
Код легко использовать, его легко понять, о нем легко рассуждать.  
Вы уверены, что ваши изменения дадут желаемый эффект без каких-либо побочных.  
Код направляет вас, приглашает вас осмотреться.  
Программисты, которые были до вас, заботились о человеке, который придёт потом.  
Возможно, они предполагали, что этим человеком, могут стать и они сами!

В своей основополагающей книге «Рефакторинг» Мартин Фаулер пишет:

> “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”
>
> — [Refactoring](https://martinfowler.com/books/refactoring.html), Martin Fowler with Kent Beck, 1996

Я прочитал это в начале 2000-х, и его слова перевернули мой мир программирования.  
А что, если хорошее программирование заключается в том, чтобы сделать код понятным для других людей?  
А что, если один из этих людей — это я в будущем?  
Это звучало как нечто, к чему можно стремиться.

Но хотя «понятность» может быть благородным стремлением, это не такая уж высокая планка!  
Примерно в то же время, когда Мартин писал о рефакторинге, пионер вычислительной техники [Ричард П. Габриэль](https://www.dreamsongs.com/) описал идею кода, который можно сделать пригодным для жизни:

> «Обитаемость — это характеристика исходного кода, которая позволяет [людям] понимать его конструкцию и намерения, а также изменять его комфортно и уверенно.  
> «Обитаемость делает место пригодным для жизни, как дом».
>
> — Habitability and Piecemeal Growth, [Patterns of Software](https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf) pp. 7-16, Richard P. Gabriel

Это больше похоже на то, к чему нужно стремиться.  
Как было бы здорово чувствовать себя комфортно и уверенно, изменяя чужой код?  
И если мы можем сделать код пригодным для жизни, что насчет удовольствия?  
Возможно ли, чтобы кодовая база приносила удовлетворение?

Если вы проводите свои рабочие дни программируя, то навигация и манипулирование кодом определяет ваш пользовательский опыт.  
Вы можете испытывать удивление, разочарование, страх, ожидание, беспомощность, надежду, радость, и все это из-за выборов, которые предыдущие программисты делали в коде.

Если мы предположим, что код может приносить удовольствие, является ли каждая кодовая база особенной снежинкой, воздействие которой на вашу психику уникально?  
Можем ли мы сформулировать, как код может приносить удовольствие, и предложить путь к достижению этого?

# Свойства превыше принципов

Когда я начал формулировать своё мнение про **пять принципов SOLID**, я представлял себе замену каждого из них чем-то, что я нахожу более полезным или актуальным.  
Вскоре я понял, что сама идея этих принципов была проблематичной.  
Принципы подобны правилам: вы либо соблюдаете их, либо нет.  
Это приводит к появлению узкого круга последователей, а не общества людей с общими ценностями.

Вместо этого я начал думать о свойствах, о качествах или характеристиках кода, а не о правилах, которым нужно следовать.  
Свойства определяют цель или центр, к которому нужно двигаться.  
Ваш код только ближе или дальше от центра, и всегда есть четкое направление движения.  
Вы можете использовать свойства в качестве линзы или фильтра для оценки своего кода и можете решить, к каким из них следует обратиться дальше.  
Поскольку все свойства CUPID взаимосвязаны, вероятно, любое изменение, которое вы внесете для улучшения одного из свойств, окажет положительное влияние на другие.

# Свойства свойств

Так как же нам выбрать такие свойства?  
Что делает свойство более или менее полезным?  
Я выбрал три **свойства свойств** CUPID:

-   практичность
-   человечность
-   многослойность

## Практичность

Чтобы быть **практичными**, свойства должны быть:

-   **легкими для формулировки**:
    чтобы вы могли описать каждое из них в нескольких предложениях и привести конкретные примеры и контрпримеры.
-   **легкими для оценки**:
    чтобы вы могли использовать их в качестве линзы для обзора и обсуждения кода, и вы можете легко решить, насколько код соответствует каждому свойству.
-   **легкими для внедрения**:
    чтобы вы могли начать с малого и постепенно развивать код по любому из измерений CUPID.
    Нет _все включено_ и нет _неудачи_, так же как никогда не бывает _полностью готово_.
    Код всегда можно улучшить.

## Человечность

Чтобы быть человечными, свойства должны читаться с точки зрения людей, а не кода.  
CUPID — это про то, как чувствуется работа с кодом, а не абстрактное описание кода как такового.  
Например, хотя философия Unix **«делать хорошо что-то одно»** может звучать как принцип единой ответственности, первый касается того, как вы используете ПО, а второй — как написан код.

## Многослойность

Чтобы быть **многослойными**, свойства должны предлагать руководство для новичков _(что является следствием простоты выражения)_ и нюансы для более опытных, которые хотят глубже изучить природу кода.  
Каждое из свойств CUPID «очевидно» только по названию и краткому описанию, но каждое воплощает множество слоев, измерений, подходов.  
Мы можем описать «центр» для каждого свойства, но есть много путей, чтобы туда попасть!

# Сочетаемость
