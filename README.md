# CUPID
*This is russian translation.*  
Original post: https://dannorth.net/cupid-for-joyful-coding  
Author: https://mas.to/@tastapod  

Автор перевода: https://t.me/noncommunicado  
Подписывайтесь: https://t.me/Dev4Devs

# Введение
То, что начиналось как легкомысленное иконоборчество, подначивание деушки SOLID'а, превратилось в нечто более конкретное и осязаемое.  
Если я считаю, что принципы SOLID бесполезны в текущих реалияъ, то чем бы я их заменил?  
Может какой-либо набор принципов быть применимым ко всему программному обеспечению?  
Что мы вообще подразумеваем под принципами?  

Я считаю, что существуют такие свойства (характеристики) кода, которые делают работу с ним **удовольствием**.  
Чем больше в вашем коде таких качеств, тем приятнее с ним работать.  
Но все является компромиссом, поэтому - вы всегда должны учитывать свой контекст.  

Вероятно, существует множество таких свойств, пересекающихся и взаимосвязанных, и существует множество способов их описания.  
Я выбрал **пять**, которые лежат в основе большей части того, что меня волнует в коде.  
Существует *убывающая отдача*, пяти свойств достаточно, чтобы легко их запомнить и сделать удобный акроним.

> Закон убывающей отдачи (или Закон убывающей доходности) - гласит, что существует такая точка увеличения одного из факторов производительности, в данном случае количества слов в акрониме, при достижении которой, производительность начинает падать.  
> Иными словами, больше (слов в акрониме) - не значит лучше.

Я подробнее расскажу о каждом свойстве в будущих статьях, чтобы эта не получилась слишком длинной, поэтому, пожалуйста, простите меня за то, что я не описал все более подробно.

## Свойства CUPID
- **Компонуемый** <sup>Composable</sup> : хорошо сочетается с другими
- **Философия Unix** <sup>Unix philosophy</sup> : хорошо решает одну задачу
- **Предсказуемый** <sup>Predictable</sup> : делает то, что вы ожидаете
- **Идиоматический** <sup>Idiomatic</sup> : кажется естественным
- **Основанный на предметной области** <sup>Domain-based</sup> : домен решения моделирует домен проблемы при помощи языка и структуры

## Преамбула: давным-давно…
> У вас было, что исследуя незнакомый чужой код, вы можете его легко понять?   
> Структура, наименование, ход мыслей автора, всё выглядит очень знакомо.  
> На вашем лице появляется улыбка.  
> «Мне все понятно!» — думаете вы.

Мне повезло испытать это несколько раз за тридцатилетнюю карьеру, и каждый раз это приносило мне удовольствие.  
Первый раз это было в начале 1990-х — я хорошо это помню.  
Я изучал огромную кодовую базу на языке `C`, которая выполняла сложную обработку изображений для цифровой печати. ​​  
В `Someone Else’s Code`™ была ошибка, и я должен был ее отследить и исправить.   
Я помню это чувство, как начинающего программиста: смесь страха и боязнь выдать себя как любителя, которым я и был тогда.  

Моя IDE (`vi` + `ctags`) позволила мне перейти к определениям функций из мест вызовов, и через несколько минут я зашел далеко по цепочке вызовов, будучи уверенным, что знаю, на что смотрю.  
Я быстро нашел виновника, которым была простая логическая ошибка, внес изменения, сделал сборку и протестировал.  
Все это было без автоматического тестирования, только с помощью `Makefiles`.  
TDD я узнал только, почти, через 10 лет, и в любом случае в `C` не было таких инструментов.  

Я запустил преобразование на нескольких образцах изображений, и они выглядели нормально.  
Я был невероятно уверен, что: 
- Нашел и исправил ошибку.
- В то же время, не внес никаких неприятных сюрпризов.

# Joyful Software

Бывает код, с которым приятно работать.  
Вы знаете, как найти то место, где нужно внести правки, и как их сделать.   
Код легко использовать, его легко понять, о нем легко рассуждать.  
Вы уверены, что ваши изменения дадут желаемый эффект без каких-либо побочных.  
Код направляет вас, приглашает вас осмотреться.  
Программисты, которые были до вас, заботились о человеке, который придёт потом.  
Возможно, они предполагали, что этим человеком, могут стать и они сами!  

В своей основополагающей книге «Рефакторинг» Мартин Фаулер пишет:
> “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”
> 
> — [Refactoring](https://martinfowler.com/books/refactoring.html), Martin Fowler with Kent Beck, 1996


Я прочитал это в начале 2000-х, и его слова перевернули мой мир программирования.  
А что, если хорошее программирование заключается в том, чтобы сделать код понятным для других людей?  
А что, если один из этих людей — это я в будущем?  
Это звучало как нечто, к чему можно стремиться.


Но хотя «понятность» может быть благородным стремлением, это не такая уж высокая планка!  
Примерно в то же время, когда Мартин писал о рефакторинге, пионер вычислительной техники [Ричард П. Габриэль](https://www.dreamsongs.com/) описал идею кода, который можно сделать пригодным для жизни:  

> «Обитаемость — это характеристика исходного кода, которая позволяет [людям] понимать его конструкцию и намерения, а также изменять его комфортно и уверенно.  
> «Обитаемость делает место пригодным для жизни, как дом».
> 
> — Habitability and Piecemeal Growth, [Patterns of Software](https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf) pp. 7-16, Richard P. Gabriel



