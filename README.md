# CUPID

_This is russian translation._  
Original post: https://dannorth.net/cupid-for-joyful-coding  
Author: https://mas.to/@tastapod

Автор перевода: https://t.me/noncommunicado  
Подписывайтесь: https://t.me/Dev4Devs

# Введение

То, что начиналось как легкомысленное иконоборчество, подначивание дедушки SOLID'а, превратилось в нечто более конкретное и осязаемое.  
Если я считаю, что принципы SOLID бесполезны в текущих реалиях, то чем бы я их заменил?  
Может есть какой-нибудь набор принципов применимый ко всему программному обеспечению?  
Что мы вообще подразумеваем под принципами?

Я считаю, что существуют такие свойства (характеристики) кода, которые делают работу **удовольствием**.  
Чем больше в вашем коде таких качеств, тем приятнее с ним работать.  
Но все является компромиссом, поэтому - вы всегда должны учитывать свою специфику.

Вероятно, существует множество таких свойств, пересекающихся и взаимосвязанных, и существует множество способов их описания.  
Я выбрал **пять**, которые лежат в основе большей части того, что меня интересует в коде.  
Существует _убывающая отдача_, пяти свойств достаточно, чтобы легко запомнить и сделать удобный акроним.

> Закон убывающей отдачи (или Закон убывающей доходности) - гласит, что существует такая точка увеличения одного из факторов производительности, в данном случае количества слов в акрониме, при достижении которой, производительность начинает падать.  
> Иными словами, больше (слов в акрониме) - не значит лучше.  
> *- от переводчика*

Я подробнее расскажу о каждом свойстве в будущих статьях, чтобы эта не получилась слишком длинной, поэтому, пожалуйста, простите меня за то, что я не описал все более подробно.

## Свойства CUPID

-   **Компонуемость** <sup>Composable</sup> : хорошо сочетается с другими
-   **Философия Unix** <sup>Unix philosophy</sup> : хорошо решает одну задачу
-   **Предсказуемость** <sup>Predictable</sup> : делает то, что вы ожидаете
-   **Идиоматичность** <sup>Idiomatic</sup> : кажется естественным
-   **Доменность** <sup>Domain-based</sup> : домен решения моделирует домен проблемы при помощи языка и структуры

## Преамбула: давным-давно…

> У вас было, что исследуя незнакомый чужой код, вы можете его легко понять?  
> Структура, наименование, ход мыслей автора, всё выглядит очень знакомо.  
> На вашем лице появляется улыбка.  
> «Мне все понятно!» — думаете вы.

Мне повезло испытать это несколько раз за тридцатилетнюю карьеру, и каждый раз это приносило мне удовольствие.  
Первый раз это было в начале 1990-х — я хорошо это помню.  
Я изучал огромную кодовую базу на языке `C`, которая выполняла сложную обработку изображений для цифровой печати. ​​  
В `Someone Else’s Code`™ была ошибка, и я должен был ее отследить и исправить.  
Я помню это чувство, как начинающего программиста: смесь страха и боязнь выдать себя как любителя, которым я и был тогда.

Моя IDE (`vi` + `ctags`) позволила мне перейти к определениям функций из мест вызовов, и через несколько минут я зашел далеко по цепочке вызовов, будучи уверенным, что знаю, на что смотрю.  
Я быстро нашел виновника, которым была простая логическая ошибка, внес изменения, сделал сборку и протестировал.  
Все это было без автоматического тестирования, только с помощью `Makefiles`.  
TDD я узнал только, почти, через 10 лет, и в любом случае в `C` не было таких инструментов.

Я запустил преобразование на нескольких образцах изображений, и они выглядели нормально.  
Я был невероятно уверен, что:

-   Нашел и исправил ошибку.
-   В то же время, не внес никаких неприятных сюрпризов.

# Joyful Software

Бывает код, с которым приятно работать.  
Вы знаете, как найти то место, где нужно внести правки, и как их сделать.  
Код легко использовать, его легко понять, о нем легко рассуждать.  
Вы уверены, что ваши изменения дадут желаемый эффект без каких-либо побочных.  
Код направляет вас, приглашает вас осмотреться.  
Программисты, которые были до вас, заботились о человеке, который придёт потом.  
Возможно, они предполагали, что этим человеком, могут стать и они сами!

В своей основополагающей книге «Рефакторинг» Мартин Фаулер пишет:

> “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”
>
> — [Refactoring](https://martinfowler.com/books/refactoring.html), Martin Fowler with Kent Beck, 1996

Я прочитал это в начале 2000-х, и его слова перевернули мой мир программирования.  
А что, если хорошее программирование заключается в том, чтобы сделать код понятным для других людей?  
А что, если один из этих людей — это я в будущем?  
Это звучало как нечто, к чему можно стремиться.

Но хотя «понятность» может быть благородным стремлением, это не такая уж высокая планка!  
Примерно в то же время, когда Мартин писал о рефакторинге, пионер вычислительной техники [Ричард П. Габриэль](https://www.dreamsongs.com/) описал идею кода, который можно сделать пригодным для жизни:

> «Обитаемость — это характеристика исходного кода, которая позволяет [людям] понимать его конструкцию и намерения, а также изменять его комфортно и уверенно.  
> «Обитаемость делает место пригодным для жизни, как дом».
>
> — Habitability and Piecemeal Growth, [Patterns of Software](https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf) pp. 7-16, Richard P. Gabriel

Это больше похоже на то, к чему нужно стремиться.  
Как было бы здорово чувствовать себя комфортно и уверенно, изменяя чужой код?  
И если мы можем сделать код пригодным для жизни, что насчет удовольствия?  
Возможно ли, чтобы кодовая база приносила удовлетворение?

Если вы проводите свои рабочие дни программируя, то навигация и манипулирование кодом определяет ваш пользовательский опыт.  
Вы можете испытывать удивление, разочарование, страх, ожидание, беспомощность, надежду, радость, и все это из-за выборов, которые предыдущие программисты делали в коде.

Если мы предположим, что код может приносить удовольствие, является ли каждая кодовая база особенной снежинкой, воздействие которой на вашу психику уникально?  
Можем ли мы сформулировать, как код может приносить удовольствие, и предложить путь к достижению этого?

# Свойства превыше принципов

Когда я начал формулировать своё мнение про **пять принципов SOLID**, я представлял себе замену каждого из них чем-то, что я нахожу более полезным или актуальным.  
Вскоре я понял, что сама идея этих принципов была проблематичной.  
Принципы подобны правилам: вы либо соблюдаете их, либо нет.  
Это приводит к появлению узкого круга последователей, а не общества людей с общими ценностями.

Вместо этого я начал думать о свойствах, о качествах или характеристиках кода, а не о правилах, которым нужно следовать.  
Свойства определяют цель или центр, к которому нужно двигаться.  
Ваш код только ближе или дальше от центра, и всегда есть четкое направление движения.  
Вы можете использовать свойства в качестве линзы или фильтра для оценки своего кода и можете решить, к каким из них следует обратиться дальше.  
Поскольку все свойства CUPID взаимосвязаны, вероятно, любое изменение, которое вы внесете для улучшения одного из свойств, окажет положительное влияние на другие.

# Свойства свойств

Так как же нам выбрать такие свойства?  
Что делает свойство более или менее полезным?  
Я выбрал три **свойства свойств** CUPID:

-   практичность
-   человечность
-   многослойность

## Практичность

Чтобы быть **практичными**, свойства должны быть:

-   **легкими для формулировки**:
    чтобы вы могли описать каждое из них в нескольких предложениях и привести конкретные примеры и контрпримеры.
-   **легкими для оценки**:
    чтобы вы могли использовать их в качестве линзы для обзора и обсуждения кода, и вы можете легко решить, насколько код соответствует каждому свойству.
-   **легкими для внедрения**:
    чтобы вы могли начать с малого и постепенно развивать код по любому из измерений CUPID.
    Нет _все включено_ и нет _неудачи_, так же как никогда не бывает _полностью готово_.
    Код всегда можно улучшить.

## Человечность

Чтобы быть человечными, свойства должны читаться с точки зрения людей, а не кода.  
CUPID — это про то, как чувствуется работа с кодом, а не абстрактное описание кода как такового.  
Например, хотя философия Unix **«делать хорошо что-то одно»** может звучать как принцип единой ответственности, первый касается того, как вы используете ПО, а второй — как написан код.

## Многослойность

Чтобы быть **многослойными**, свойства должны предлагать руководство для новичков _(что является следствием простоты выражения)_ и нюансы для более опытных, которые хотят глубже изучить природу кода.  
Каждое из свойств CUPID «очевидно» только по названию и краткому описанию, но каждое воплощает множество слоев, измерений, подходов.  
Мы можем описать «центр» для каждого свойства, но есть много путей, чтобы туда попасть!

# Компонуемость

Программой с удобным интерфейсом хочется пользоваться снова и снова.  
Существует несколько характеристик которые делают код более или менее компонуемым, но они не являются ни необходимыми, ни достаточными для предоставления каких-либо гарантий.  
В каждом случае мы можем найти контрпримеры с обеих сторон, подумаем об этом как о полезной эвристике.  
Больше - не обязательно лучше; должен быть компромисс.  

## Малая область применения

Вам потребуется меньше времени, чтобы изучить код с ограниченным API *(ограниченным по области применения)*. В таком коде меньше шанс, что что-то пойдет не так, что возникнет конфликт с другим кодом, который вы используете. Вернемся к **убывающей отдаче**: Если ваши API **слишком** ограничены в области применения, вам придется использовать несколько таких API вместе, и знание "правильных комбинаций" для типичных сценариев использования становится "особым знанием", а это препятствие для пользователя. Так, работа над гранулярностью API более трудна, чем кажется. Между фрагментарностью и раздутостью существует некая золотая середина «идеальной» связанности.

## Самодокументируемость

Самодокументируемый код легко читать и править. Легко найти нужный компонент и определить требуемое место в коде. Мне нравится одна модель, как из давнего open-source проекта [XStream](https://x-stream.github.io/tutorial.html), наличие 2-х минутного туториала, а еще и 10-ти минутного, и полной документации. Это дает мне возможность разбираться "небольшими порциями", понять, что это не для меня, на раннем этапе.

Часто, я начинал создавать класс придумывая самодокументируемое название, а IDE подсказывало мне, что такое название уже занято. Обычно оказывалось, что кому-то другому пришла в голову такая-же идея, и я случайно обнаружил их код, потому что мы выбрали одинаковые названия. Это было не просто совпадение, мы свободно владели одним и тем же доменом, что повышало вероятность того, что мы выберем похожие имена. Так обычно случается, когда вы пишите доменно-ориентированный код.

## Минимум зависимостей

Чем меньше зависимостей в коде, тем меньше несовместимостей версий или билиотек. Я написал свой первый open-source проект, [XJB](https://github.com/codehaus/xjb), на Java, используя популярный фреймворк логирования `log4j`. Коллега подсказал, что это создает зависимость не только от `log4j` как библиотеки, но и от конкретной её версии. Мне это даже в голову не приходило: почему кто-то должен беспокоиться о совместимости библиотеки логирования в моём коде?  
Так что мы убрали эту зависимость и целый [другой проект](https://github.com/proxytoys), который делал интересные вещи с Java dynamic proxy. 

# Философия Unix

Unix и я примерно одного возраста; мы оба начали в 1969 году, и Unix стал самой распространенной ОС на планете. В 1990-х годах у каждого серьезного производителя компьютерного оборудования был свой Unix, пока ключевые варианты с открытым исходным кодом, Linux и FreeBSD, не стали повсеместными.  
В наши дни он запускает почти все бизнес-серверы, как облачные, так и локальные; он работает во встроенных системах и сетевых устройствах; он лежит в основе операционных систем MacOS и Android; он даже поставляется как дополнительная подсистема с Microsoft Windows!

## Простая, последовательная модель

Так как же нишевая операционная система, которая зародилась в исследовательской лаборатории телекоммуникаций, была скопирована в качестве хобби-проекта студентом колледжа и в итоге стала крупнейшей операционной системой в мире?  
Несомненно, существуют коммерческие и юридические причины ее успеха в эпоху, когда поставщики ОС были так же известны своими судебными исками друг против друга, как и своими технологиями, но ее непреходящая техническая привлекательность заключается в ее простой и последовательной [философии дизайна](https://en.wikipedia.org/wiki/Unix_philosophy).  

Согласно философии Unix следует писать компоненты, которые хорошо работают вместе, и которые *делают что-то одно, и делают это хорошо*. Для примера, команда `ls` выводит информацию о каталогах и файлах, но она **ничего** не знает о каталогах и файлах! Команда `stat` предоставляет всю информацию, а `ls` просто утилита для предоставления информации в виде текста.  

Аналогично, команда `cat` выводит (объединяет) содержимое одного или нескольких файлов, `grep` выбирает текст, который соответствует заданному шаблону, `sed` заменяет текстовые шаблоны и т.д.  
В командной строке Unix есть мощная концепция «конвейеров», которые присоединяют вывод одной команды в качестве ввода к следующей, создавая конвейер выбора, преобразования, фильтрации, сортировки и т.д.  
Вы можете писать сложные программы обработки текста и данных, основанные на составлении нескольких хорошо продуманных команд, каждая из которых *делает что-то одно, и делает это хорошо*.

## Единая цель против Единой ответственности

На первый взгляд это похоже на принцип единой ответственности (Single Responsibility Principle), и с некоторыми интерпретациями SRP есть пересечение. Но **"делать хорошо что-то одно"** — это взгляд снаружи; это свойство иметь конкретную, четко определенную и всеобъемлющую цель.  
SRP — это взгляд изнутри: он касается организации кода.

SRP, по словам Роберта Мартина *(автора термина)* заключается в том, что код [«должен иметь одну и только одну причину для изменения»](https://en.wikipedia.org/wiki/Single-responsibility_principle). Пример в статье Википедии — это модуль создания отчета, в котором предлагается рассматривать содержание и формат отчета как отдельные проблемы, которые должны находиться в отдельных классах или даже отдельных модулях. Как я уже говорил в [другом месте](https://dannorth.net/cupid-the-back-story/), по моему опыту, это создает искусственные границы, и наиболее распространенным является случай, когда содержание и формат данных изменяются вместе; например, добавление **нового поля** или изменение источника данных (что повлияет как на содержание, так и на способ отображения).

"Компонент UI" - это часты пример, где SRP требует, разделения бизнес логики и рендеринга компонентов. Разделение этих элементов - рутина по работе с идентичными полями моделей.  
Главная опасность - преждевременная оптимизация, которая может затруднить естественное разделение задач, возникающих по мере роста кодовой базы, и по мере появления компонентов "хорошо решающих одну задачу" и более подходящих под доменную модель приложения.  
По мере роста любой кодовой базы, приходит время для смысловой декомпозиции. Однако, свойство Компонуемости (возможность быть составным) и доменно-ориентированная структура - лучшие индикаторы **как** и **когда** вносить такие структурные изменения. 

# Предсказуемость поведения

Код должен работать так, как мы этого ожидаем, последовательно и надежно, без неприятных сюрпризов. Соответствие такому поведению должно быть легко верифицируемым. В этом смысле, предсказуемость поведения является обобщением тестируемости.  

Код с предсказуемым поведением должен быть *детерминированным* и *наблюдаемым*, вести себя так, как *ожидается*.

## Выполнение "как ожидается"

Первое из [четырех правил простого дизайна](https://www.martinfowler.com/bliki/BeckDesignRules.html) Кента Бека заключается в том, что код «проходит все тесты».  
Это должно быть верно даже тогда, когда нет тестов! Предполагаемое поведение предсказуемого кода должно быть очевидно из его структуры и наименования.  
Если нет автоматизированных тестов, их создание должно быть простым. Майкл Фезерс называет это [характеризационным тестированием](https://michaelfeathers.silvrback.com/characterization-testing). По его словам:

> "Когда система публикуется, она, в некотором смысле, становится собственной спецификацией." *- Майкл Фезерс*

Я обнаружил, что некоторые люди считают разработку на основе тестирования религией, а не инструментом. Однажды я работал над сложным приложением для алгоритмической торговли, которое имело около 7% покрытия тестами. Эти тесты были распределены неравномерно!  
Большая часть кода вообще не содержала автоматизированных тестов, а некоторые содержали сумасшедшее количество сложных тестов, проверяющих на наличие едва заметных ошибок и крайних случаев.  
Внося изменения, я был уверен в себе, потому что каждый из компонентов выполнял одну задачу, и его поведение было простым и предсказуемым, так что изменения обычно были очевидны.

## Детерменированность

Код должен выполняться одинакого каждый запуск. Даже код, разработанный как недетерминированный - скажем, генератор случайных чисел или динамический вычислитель, — будет иметь рабочие или функциональные ограничения, которые вы можете определить. Вы должны уметь прогнозировать границы памяти, сети, хранилища или обработки, временные границы и ожидания в отношении других зависимостей.

Детерминизм - это широкая тема. В целях предсказуемости детерминированный код должен быть *устойчивым*, *стабильным* и *стойким*.

- **Устойчивость** - это *ширина* или *полнота* охватываемых ситуаций. Ограничения и крайние случаи должны быть очевидны.
- **Стабильность** - это функционирование *согласно ожиданиям*. Мы должны каждый раз получать одни и те же результаты.
- **Стойкость** - это то, насколько хорошо мы справляемся с ситуациями, которые мы не описываем; *неожиданные изменения* в вводимых данных или среде выполнения.  

## Наблюдаемость

Код должен быть наблюдаемым в [смысле теории управления](https://en.wikipedia.org/wiki/Observability): мы можем сделать выводы о внутреннее состоянии из вывода программы. Это возможно только на этапе проектирования. Как только несколько компонентов взаимодействуют, особенно асинхронно, будет возникать непредвиденное поведение и нелинейные последствия.

Оснащение кода специальными средствами с самого начала позволяет собирать ценные данные, чтобы понять его поведение во время выполнения. Я предлагаю модель из четырех этапов — с двумя дополнительными! — которая выглядит следующим образом:

1. **Оснащение** — программное обеспечение, собирает свои метрики.
2. **Телеметрия** - делает эту информацию доступной, будь то путем опроса объекта — или принимая сообщения от объекта.
3. **Мониторинг** — это получение, накопление *оснащения* и его отображение.
4. **Оповещение** — это реакция на отслеживаемые данные или закономерности в данных.  
Бонус:
5. **Прогнозирование** — использование данных для предугадывания событий.
6. **Адаптация** — это динамическое изменение системы, либо для предотвращения, либо для восстановления после инцидента.

Большинство программ не продвигаются дальше шага №1. Существуют инструменты, которые перехватывают или изменяют работающие системы, чтобы повысить уровень понимания, но они никогда не сравнятся с преднамеренным оснащением, встроенным в приложение.

# Idiomatic